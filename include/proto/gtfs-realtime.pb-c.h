/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: proto/gtfs-realtime.proto */

#ifndef PROTOBUF_C_proto_2fgtfs_2drealtime_2eproto__INCLUDED
#define PROTOBUF_C_proto_2fgtfs_2drealtime_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protobuf-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1005002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protobuf-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protobuf-c.
#endif


typedef struct TransitRealtime__FeedMessage TransitRealtime__FeedMessage;
typedef struct TransitRealtime__FeedHeader TransitRealtime__FeedHeader;
typedef struct TransitRealtime__FeedEntity TransitRealtime__FeedEntity;
typedef struct TransitRealtime__TripUpdate TransitRealtime__TripUpdate;
typedef struct TransitRealtime__TripUpdate__StopTimeEvent TransitRealtime__TripUpdate__StopTimeEvent;
typedef struct TransitRealtime__TripUpdate__StopTimeUpdate TransitRealtime__TripUpdate__StopTimeUpdate;
typedef struct TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties;
typedef struct TransitRealtime__TripUpdate__TripProperties TransitRealtime__TripUpdate__TripProperties;
typedef struct TransitRealtime__VehiclePosition TransitRealtime__VehiclePosition;
typedef struct TransitRealtime__VehiclePosition__CarriageDetails TransitRealtime__VehiclePosition__CarriageDetails;
typedef struct TransitRealtime__Alert TransitRealtime__Alert;
typedef struct TransitRealtime__TimeRange TransitRealtime__TimeRange;
typedef struct TransitRealtime__Position TransitRealtime__Position;
typedef struct TransitRealtime__TripDescriptor TransitRealtime__TripDescriptor;
typedef struct TransitRealtime__TripDescriptor__ModifiedTripSelector TransitRealtime__TripDescriptor__ModifiedTripSelector;
typedef struct TransitRealtime__VehicleDescriptor TransitRealtime__VehicleDescriptor;
typedef struct TransitRealtime__EntitySelector TransitRealtime__EntitySelector;
typedef struct TransitRealtime__TranslatedString TransitRealtime__TranslatedString;
typedef struct TransitRealtime__TranslatedString__Translation TransitRealtime__TranslatedString__Translation;
typedef struct TransitRealtime__TranslatedImage TransitRealtime__TranslatedImage;
typedef struct TransitRealtime__TranslatedImage__LocalizedImage TransitRealtime__TranslatedImage__LocalizedImage;
typedef struct TransitRealtime__Shape TransitRealtime__Shape;
typedef struct TransitRealtime__Stop TransitRealtime__Stop;
typedef struct TransitRealtime__TripModifications TransitRealtime__TripModifications;
typedef struct TransitRealtime__TripModifications__Modification TransitRealtime__TripModifications__Modification;
typedef struct TransitRealtime__TripModifications__SelectedTrips TransitRealtime__TripModifications__SelectedTrips;
typedef struct TransitRealtime__StopSelector TransitRealtime__StopSelector;
typedef struct TransitRealtime__ReplacementStop TransitRealtime__ReplacementStop;


/* --- enums --- */

/*
 * Determines whether the current fetch is incremental.  Currently,
 * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
 * that use this mode.  There are discussions on the GTFS Realtime mailing
 * list around fully specifying the behavior of DIFFERENTIAL mode and the
 * documentation will be updated when those discussions are finalized.
 */
typedef enum _TransitRealtime__FeedHeader__Incrementality {
  TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY__FULL_DATASET = 0,
  TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY__DIFFERENTIAL = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY)
} TransitRealtime__FeedHeader__Incrementality;
typedef enum _TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties__DropOffPickupType {
  /*
   * Regularly scheduled pickup/dropoff.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__DROP_OFF_PICKUP_TYPE__REGULAR = 0,
  /*
   * No pickup/dropoff available
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__DROP_OFF_PICKUP_TYPE__NONE = 1,
  /*
   * Must phone agency to arrange pickup/dropoff.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__DROP_OFF_PICKUP_TYPE__PHONE_AGENCY = 2,
  /*
   * Must coordinate with driver to arrange pickup/dropoff.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__DROP_OFF_PICKUP_TYPE__COORDINATE_WITH_DRIVER = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__DROP_OFF_PICKUP_TYPE)
} TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties__DropOffPickupType;
/*
 * The relation between the StopTimeEvents and the static schedule.
 */
typedef enum _TransitRealtime__TripUpdate__StopTimeUpdate__ScheduleRelationship {
  /*
   * The vehicle is proceeding in accordance with its static schedule of
   * stops, although not necessarily according to the times of the schedule.
   * At least one of arrival and departure must be provided. If the schedule
   * for this stop contains both arrival and departure times then so must
   * this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
   * should not have a SCHEDULED value and should use UNSCHEDULED instead.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__SCHEDULED = 0,
  /*
   * The stop is skipped, i.e., the vehicle will not stop at this stop.
   * Arrival and departure are optional.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__SKIPPED = 1,
  /*
   * No StopTimeEvents are given for this stop.
   * The main intention for this value is to give time predictions only for
   * part of a trip, i.e., if the last update for a trip has a NO_DATA
   * specifier, then StopTimeEvents for the rest of the stops in the trip
   * are considered to be unspecified as well.
   * Neither arrival nor departure should be supplied.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__NO_DATA = 2,
  /*
   * The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
   * This value should not be used for trips that are not defined in GTFS frequencies.txt,
   * or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
   * with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
   * NOTE: This field is still experimental, and subject to change. It may be
   * formally adopted in the future.
   */
  TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__UNSCHEDULED = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP)
} TransitRealtime__TripUpdate__StopTimeUpdate__ScheduleRelationship;
typedef enum _TransitRealtime__VehiclePosition__VehicleStopStatus {
  /*
   * The vehicle is just about to arrive at the stop (on a stop
   * display, the vehicle symbol typically flashes).
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__INCOMING_AT = 0,
  /*
   * The vehicle is standing at the stop.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__STOPPED_AT = 1,
  /*
   * The vehicle has departed and is in transit to the next stop.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__IN_TRANSIT_TO = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS)
} TransitRealtime__VehiclePosition__VehicleStopStatus;
/*
 * Congestion level that is affecting this vehicle.
 */
typedef enum _TransitRealtime__VehiclePosition__CongestionLevel {
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__UNKNOWN_CONGESTION_LEVEL = 0,
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__RUNNING_SMOOTHLY = 1,
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__STOP_AND_GO = 2,
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__CONGESTION = 3,
  /*
   * People leaving their cars.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__SEVERE_CONGESTION = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL)
} TransitRealtime__VehiclePosition__CongestionLevel;
/*
 * The state of passenger occupancy for the vehicle or carriage.
 * Individual producers may not publish all OccupancyStatus values. Therefore, consumers
 * must not assume that the OccupancyStatus values follow a linear scale.
 * Consumers should represent OccupancyStatus values as the state indicated 
 * and intended by the producer. Likewise, producers must use OccupancyStatus values that
 * correspond to actual vehicle occupancy states.
 * For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
 * This field is still experimental, and subject to change. It may be formally adopted in the future.
 */
typedef enum _TransitRealtime__VehiclePosition__OccupancyStatus {
  /*
   * The vehicle or carriage is considered empty by most measures, and has few or no
   * passengers onboard, but is still accepting passengers.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__EMPTY = 0,
  /*
   * The vehicle or carriage has a large number of seats available.
   * The amount of free seats out of the total seats available to be
   * considered large enough to fall into this category is determined at the
   * discretion of the producer.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__MANY_SEATS_AVAILABLE = 1,
  /*
   * The vehicle or carriage has a relatively small number of seats available.
   * The amount of free seats out of the total seats available to be
   * considered small enough to fall into this category is determined at the
   * discretion of the feed producer.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__FEW_SEATS_AVAILABLE = 2,
  /*
   * The vehicle or carriage can currently accommodate only standing passengers.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__STANDING_ROOM_ONLY = 3,
  /*
   * The vehicle or carriage can currently accommodate only standing passengers
   * and has limited space for them.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__CRUSHED_STANDING_ROOM_ONLY = 4,
  /*
   * The vehicle or carriage is considered full by most measures, but may still be
   * allowing passengers to board.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__FULL = 5,
  /*
   * The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__NOT_ACCEPTING_PASSENGERS = 6,
  /*
   * The vehicle or carriage doesn't have any occupancy data available at that time.
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__NO_DATA_AVAILABLE = 7,
  /*
   * The vehicle or carriage is not boardable and never accepts passengers.
   * Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
   */
  TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__NOT_BOARDABLE = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS)
} TransitRealtime__VehiclePosition__OccupancyStatus;
/*
 * Cause of this alert. If cause_detail is included, then Cause must also be included.
 */
typedef enum _TransitRealtime__Alert__Cause {
  TRANSIT_REALTIME__ALERT__CAUSE__UNKNOWN_CAUSE = 1,
  /*
   * Not machine-representable.
   */
  TRANSIT_REALTIME__ALERT__CAUSE__OTHER_CAUSE = 2,
  TRANSIT_REALTIME__ALERT__CAUSE__TECHNICAL_PROBLEM = 3,
  /*
   * Public transit agency employees stopped working.
   */
  TRANSIT_REALTIME__ALERT__CAUSE__STRIKE = 4,
  /*
   * People are blocking the streets.
   */
  TRANSIT_REALTIME__ALERT__CAUSE__DEMONSTRATION = 5,
  TRANSIT_REALTIME__ALERT__CAUSE__ACCIDENT = 6,
  TRANSIT_REALTIME__ALERT__CAUSE__HOLIDAY = 7,
  TRANSIT_REALTIME__ALERT__CAUSE__WEATHER = 8,
  TRANSIT_REALTIME__ALERT__CAUSE__MAINTENANCE = 9,
  TRANSIT_REALTIME__ALERT__CAUSE__CONSTRUCTION = 10,
  TRANSIT_REALTIME__ALERT__CAUSE__POLICE_ACTIVITY = 11,
  TRANSIT_REALTIME__ALERT__CAUSE__MEDICAL_EMERGENCY = 12
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__ALERT__CAUSE)
} TransitRealtime__Alert__Cause;
/*
 * What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
 */
typedef enum _TransitRealtime__Alert__Effect {
  TRANSIT_REALTIME__ALERT__EFFECT__NO_SERVICE = 1,
  TRANSIT_REALTIME__ALERT__EFFECT__REDUCED_SERVICE = 2,
  /*
   * We don't care about INsignificant delays: they are hard to detect, have
   * little impact on the user, and would clutter the results as they are too
   * frequent.
   */
  TRANSIT_REALTIME__ALERT__EFFECT__SIGNIFICANT_DELAYS = 3,
  TRANSIT_REALTIME__ALERT__EFFECT__DETOUR = 4,
  TRANSIT_REALTIME__ALERT__EFFECT__ADDITIONAL_SERVICE = 5,
  TRANSIT_REALTIME__ALERT__EFFECT__MODIFIED_SERVICE = 6,
  TRANSIT_REALTIME__ALERT__EFFECT__OTHER_EFFECT = 7,
  TRANSIT_REALTIME__ALERT__EFFECT__UNKNOWN_EFFECT = 8,
  TRANSIT_REALTIME__ALERT__EFFECT__STOP_MOVED = 9,
  TRANSIT_REALTIME__ALERT__EFFECT__NO_EFFECT = 10,
  TRANSIT_REALTIME__ALERT__EFFECT__ACCESSIBILITY_ISSUE = 11
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__ALERT__EFFECT)
} TransitRealtime__Alert__Effect;
/*
 * Severity of this alert.
 */
typedef enum _TransitRealtime__Alert__SeverityLevel {
  TRANSIT_REALTIME__ALERT__SEVERITY_LEVEL__UNKNOWN_SEVERITY = 1,
  TRANSIT_REALTIME__ALERT__SEVERITY_LEVEL__INFO = 2,
  TRANSIT_REALTIME__ALERT__SEVERITY_LEVEL__WARNING = 3,
  TRANSIT_REALTIME__ALERT__SEVERITY_LEVEL__SEVERE = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__ALERT__SEVERITY_LEVEL)
} TransitRealtime__Alert__SeverityLevel;
/*
 * The relation between this trip and the static schedule. If a trip is done
 * in accordance with temporary schedule, not reflected in GTFS, then it
 * shouldn't be marked as SCHEDULED, but likely as ADDED.
 */
typedef enum _TransitRealtime__TripDescriptor__ScheduleRelationship {
  /*
   * Trip that is running in accordance with its GTFS schedule, or is close
   * enough to the scheduled trip to be associated with it.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__SCHEDULED = 0,
  /*
   * This value has been deprecated as the behavior was unspecified. 
   * Use DUPLICATED for an extra trip that is the same as a scheduled trip except the start date or time, 
   * or NEW for an extra trip that is unrelated to an existing trip.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__ADDED = 1,
  /*
   * A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
   * Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__UNSCHEDULED = 2,
  /*
   * A trip that existed in the schedule but was removed.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__CANCELED = 3,
  /*
   * A trip that replaces an existing trip in the schedule.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__REPLACEMENT = 5,
  /*
   * An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
   * respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
   * and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
   * date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
   * (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
   * identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
   * TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
   * TripUpdate with the value of CANCELED or DELETED. If a producer wants to replace the original trip, a value of 
   * `REPLACEMENT` should be used instead.
   * Trips defined in GTFS frequencies.txt with exact_times that is
   * empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
   * the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
   * must also be set to DUPLICATED.
   * Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
   * the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
   * to transition to the DUPLICATED enumeration.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__DUPLICATED = 6,
  /*
   * A trip that existed in the schedule but was removed and must not be shown to users.
   * DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
   * information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
   * riders, e.g. a trip that is entirely being replaced by another trip.
   * This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
   * If consumers were to show explicit information about the cancellations it would distract from the more important
   * real-time predictions.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__DELETED = 7,
  /*
   * An extra trip unrelated to any existing trips, for example, to respond to sudden passenger load.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__NEW = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP)
} TransitRealtime__TripDescriptor__ScheduleRelationship;
typedef enum _TransitRealtime__VehicleDescriptor__WheelchairAccessible {
  /*
   * The trip doesn't have information about wheelchair accessibility.
   * This is the **default** behavior. If the static GTFS contains a
   * _wheelchair_accessible_ value, it won't be overwritten.
   */
  TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__NO_VALUE = 0,
  /*
   * The trip has no accessibility value present.
   * This value will overwrite the value from the GTFS.
   */
  TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__UNKNOWN = 1,
  /*
   * The trip is wheelchair accessible.
   * This value will overwrite the value from the GTFS.
   */
  TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__WHEELCHAIR_ACCESSIBLE = 2,
  /*
   * The trip is **not** wheelchair accessible.
   * This value will overwrite the value from the GTFS.
   */
  TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__WHEELCHAIR_INACCESSIBLE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE)
} TransitRealtime__VehicleDescriptor__WheelchairAccessible;
typedef enum _TransitRealtime__Stop__WheelchairBoarding {
  TRANSIT_REALTIME__STOP__WHEELCHAIR_BOARDING__UNKNOWN = 0,
  TRANSIT_REALTIME__STOP__WHEELCHAIR_BOARDING__AVAILABLE = 1,
  TRANSIT_REALTIME__STOP__WHEELCHAIR_BOARDING__NOT_AVAILABLE = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSIT_REALTIME__STOP__WHEELCHAIR_BOARDING)
} TransitRealtime__Stop__WheelchairBoarding;

/* --- messages --- */

/*
 * The contents of a feed message.
 * A feed is a continuous stream of feed messages. Each message in the stream is
 * obtained as a response to an appropriate HTTP GET request.
 * A realtime feed is always defined with relation to an existing GTFS feed.
 * All the entity ids are resolved with respect to the GTFS feed.
 * Note that "required" and "optional" as stated in this file refer to Protocol
 * Buffer cardinality, not semantic cardinality.  See reference.md at
 * https://github.com/google/transit/tree/master/gtfs-realtime for field
 * semantic cardinality.
 */
struct  TransitRealtime__FeedMessage
{
  ProtobufCMessage base;
  /*
   * Metadata about this feed and feed message.
   */
  TransitRealtime__FeedHeader *header;
  /*
   * Contents of the feed.
   */
  size_t n_entity;
  TransitRealtime__FeedEntity **entity;
};
#define TRANSIT_REALTIME__FEED_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__feed_message__descriptor) \
, NULL, 0,NULL }


/*
 * Metadata about a feed, included in feed messages.
 */
struct  TransitRealtime__FeedHeader
{
  ProtobufCMessage base;
  /*
   * Version of the feed specification.
   * The current version is 2.0.  Valid versions are "2.0", "1.0".
   */
  char *gtfs_realtime_version;
  protobuf_c_boolean has_incrementality;
  TransitRealtime__FeedHeader__Incrementality incrementality;
  /*
   * This timestamp identifies the moment when the content of this feed has been
   * created (in server time). In POSIX time (i.e., number of seconds since
   * January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
  /*
   * String that matches the feed_info.feed_version from the GTFS feed that the real
   * time data is based on. Consumers can use this to identify which GTFS feed is
   * currently active or when a new one is available to download.
   */
  char *feed_version;
};
#define TRANSIT_REALTIME__FEED_HEADER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__feed_header__descriptor) \
, NULL, 0, TRANSIT_REALTIME__FEED_HEADER__INCREMENTALITY__FULL_DATASET, 0, 0, NULL }


/*
 * A definition (or update) of an entity in the transit feed.
 */
struct  TransitRealtime__FeedEntity
{
  ProtobufCMessage base;
  /*
   * The ids are used only to provide incrementality support. The id should be
   * unique within a FeedMessage. Consequent FeedMessages may contain
   * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
   * FeedEntity with some id will replace the old FeedEntity with the same id
   * (or delete it - see is_deleted below).
   * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
   * feed must be specified by explicit selectors (see EntitySelector below for
   * more info).
   */
  char *id;
  /*
   * Whether this entity is to be deleted. Relevant only for incremental
   * fetches.
   */
  protobuf_c_boolean has_is_deleted;
  protobuf_c_boolean is_deleted;
  /*
   * Data about the entity itself. Exactly one of the following fields must be
   * present (unless the entity is being deleted).
   */
  TransitRealtime__TripUpdate *trip_update;
  TransitRealtime__VehiclePosition *vehicle;
  TransitRealtime__Alert *alert;
  /*
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TransitRealtime__Shape *shape;
  TransitRealtime__Stop *stop;
  TransitRealtime__TripModifications *trip_modifications;
};
#define TRANSIT_REALTIME__FEED_ENTITY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__feed_entity__descriptor) \
, NULL, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL }


/*
 * Timing information for a single predicted event (either arrival or
 * departure).
 * Timing consists of delay and/or estimated time, and uncertainty.
 * - delay should be used when the prediction is given relative to some
 *   existing schedule in GTFS.
 * - time should be given whether there is a predicted schedule or not. If
 *   both time and delay are specified, time will take precedence
 *   (although normally, time, if given for a scheduled trip, should be
 *   equal to scheduled time in GTFS + delay).
 * Uncertainty applies equally to both time and delay.
 * The uncertainty roughly specifies the expected error in true delay (but
 * note, we don't yet define its precise statistical meaning). It's possible
 * for the uncertainty to be 0, for example for trains that are driven under
 * computer timing control.
 */
struct  TransitRealtime__TripUpdate__StopTimeEvent
{
  ProtobufCMessage base;
  /*
   * Delay (in seconds) can be positive (meaning that the vehicle is late) or
   * negative (meaning that the vehicle is ahead of schedule). Delay of 0
   * means that the vehicle is exactly on time.
   */
  protobuf_c_boolean has_delay;
  int32_t delay;
  /*
   * Event as absolute time.
   * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
   * UTC).
   */
  protobuf_c_boolean has_time;
  int64_t time;
  /*
   * If uncertainty is omitted, it is interpreted as unknown.
   * If the prediction is unknown or too uncertain, the delay (or time) field
   * should be empty. In such case, the uncertainty field is ignored.
   * To specify a completely certain prediction, set its uncertainty to 0.
   */
  protobuf_c_boolean has_uncertainty;
  int32_t uncertainty;
  /*
   * Scheduled time for a NEW, REPLACEMENT, or DUPLICATED trip.
   * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
   * UTC).
   * Optional if TripUpdate.schedule_relationship is NEW, REPLACEMENT or DUPLICATED, forbidden otherwise.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_scheduled_time;
  int64_t scheduled_time;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_EVENT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__stop_time_event__descriptor) \
, 0, 0, 0, 0, 0, 0, 0, 0 }


/*
 * Provides the updated values for the stop time.
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties
{
  ProtobufCMessage base;
  /*
   * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
   * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
   * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
   * "unusual change" if the new stop was presented within an app without any additional context.
   * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
   * same station as the stop originally defined in GTFS stop_times.txt.
   * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
   * StopTimeUpdate.schedule_relationship = NO_DATA.
   * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
   * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
   * Platform assignments should be reflected in other GTFS-realtime fields as well
   * (e.g., `VehiclePosition.stop_id`).
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *assigned_stop_id;
  /*
   * The updated headsign of the vehicle at the stop.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *stop_headsign;
  /*
   * The updated pickup of the vehicle at the stop.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_pickup_type;
  TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties__DropOffPickupType pickup_type;
  /*
   * The updated drop off of the vehicle at the stop.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_drop_off_type;
  TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties__DropOffPickupType drop_off_type;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__stop_time_update__stop_time_properties__descriptor) \
, NULL, NULL, 0, TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__DROP_OFF_PICKUP_TYPE__REGULAR, 0, TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__STOP_TIME_PROPERTIES__DROP_OFF_PICKUP_TYPE__REGULAR }


/*
 * Realtime update for arrival and/or departure events for a given stop on a
 * trip. Updates can be supplied for both past and future events.
 * The producer is allowed, although not required, to drop past events.
 */
struct  TransitRealtime__TripUpdate__StopTimeUpdate
{
  ProtobufCMessage base;
  /*
   * Must be the same as in stop_times.txt in the corresponding GTFS feed.
   */
  protobuf_c_boolean has_stop_sequence;
  uint32_t stop_sequence;
  /*
   * Must be the same as in stops.txt in the corresponding GTFS feed.
   */
  char *stop_id;
  TransitRealtime__TripUpdate__StopTimeEvent *arrival;
  TransitRealtime__TripUpdate__StopTimeEvent *departure;
  /*
   * Expected occupancy after departure from the given stop.
   * Should be provided only for future stops.
   * In order to provide departure_occupancy_status without either arrival or
   * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
   */
  protobuf_c_boolean has_departure_occupancy_status;
  TransitRealtime__VehiclePosition__OccupancyStatus departure_occupancy_status;
  protobuf_c_boolean has_schedule_relationship;
  TransitRealtime__TripUpdate__StopTimeUpdate__ScheduleRelationship schedule_relationship;
  /*
   * Realtime updates for certain properties defined within GTFS stop_times.txt
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties *stop_time_properties;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__stop_time_update__descriptor) \
, 0, 0, NULL, NULL, NULL, 0, TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__EMPTY, 0, TRANSIT_REALTIME__TRIP_UPDATE__STOP_TIME_UPDATE__SCHEDULE_RELATIONSHIP__SCHEDULED, NULL }


/*
 * Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
 * trip_id, start_date, and start_time of a DUPLICATED trip. 
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__TripUpdate__TripProperties
{
  ProtobufCMessage base;
  /*
   * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
   * but will start at a different service date and/or time (defined using the TripProperties.start_date and
   * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
   * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
   * be populated and will be ignored by consumers.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *trip_id;
  /*
   * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
   * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *start_date;
  /*
   * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
   * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
   * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
   * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
   * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
   * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
   * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
   * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
   * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
   * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
   * populated and will be ignored by consumers.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *start_time;
  /*
   * Specifies the identifier of the shape of the vehicle travel path when the trip shape differs from the shape specified in (CSV) GTFS
   * or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS.
   * If a shape is neither defined in (CSV) GTFS nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt or a `Shape` in the same (protobuf) real-time feed. 
   * The order of stops (stop sequences) for this trip must remain the same as (CSV) GTFS. 
   * If it refers to a `Shape` entity in the same real-time feed, the value of this field should be the one of the `shape_id` inside the entity, and _not_ the `id` of `FeedEntity`.
   * Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should be marked as schedule_relationship=SKIPPED or more details can be provided via a `TripModifications` message.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
   */
  char *shape_id;
  /*
   * Specifies the headsign for this trip when it differs from the original.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *trip_headsign;
  /*
   * Specifies the name for this trip when it differs from the original.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *trip_short_name;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__TRIP_PROPERTIES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__trip_properties__descriptor) \
, NULL, NULL, NULL, NULL, NULL, NULL }


/*
 * Realtime update of the progress of a vehicle along a trip.
 * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
 * - A trip that proceeds along the schedule.
 * - A trip that proceeds along a route but has no fixed schedule.
 * - A trip that have been added or removed with regard to schedule.
 * The updates can be for future, predicted arrival/departure events, or for
 * past events that already occurred.
 * Normally, updates should get more precise and more certain (see
 * uncertainty below) as the events gets closer to current time.
 * Even if that is not possible, the information for past events should be
 * precise and certain. In particular, if an update points to time in the past
 * but its update's uncertainty is not 0, the client should conclude that the
 * update is a (wrong) prediction and that the trip has not completed yet.
 * Note that the update can describe a trip that is already completed.
 * To this end, it is enough to provide an update for the last stop of the trip.
 * If the time of that is in the past, the client will conclude from that that
 * the whole trip is in the past (it is possible, although inconsequential, to
 * also provide updates for preceding stops).
 * This option is most relevant for a trip that has completed ahead of schedule,
 * but according to the schedule, the trip is still proceeding at the current
 * time. Removing the updates for this trip could make the client assume
 * that the trip is still proceeding.
 * Note that the feed provider is allowed, but not required, to purge past
 * updates - this is one case where this would be practically useful.
 */
struct  TransitRealtime__TripUpdate
{
  ProtobufCMessage base;
  /*
   * The Trip that this message applies to. There can be at most one
   * TripUpdate entity for each actual trip instance.
   * If there is none, that means there is no prediction information available.
   * It does *not* mean that the trip is progressing according to schedule.
   */
  TransitRealtime__TripDescriptor *trip;
  /*
   * Additional information on the vehicle that is serving this trip.
   */
  TransitRealtime__VehicleDescriptor *vehicle;
  /*
   * Updates to StopTimes for the trip (both future, i.e., predictions, and in
   * some cases, past ones, i.e., those that already happened).
   * The updates must be sorted by stop_sequence, and apply for all the
   * following stops of the trip up to the next specified one.
   * Example 1:
   * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
   * delay of 0 for stop_sequence of the current stop means that the trip is
   * exactly on time.
   * Example 2:
   * For the same trip instance, 3 StopTimeUpdates are provided:
   * - delay of 5 min for stop_sequence 3
   * - delay of 1 min for stop_sequence 8
   * - delay of unspecified duration for stop_sequence 10
   * This will be interpreted as:
   * - stop_sequences 3,4,5,6,7 have delay of 5 min.
   * - stop_sequences 8,9 have delay of 1 min.
   * - stop_sequences 10,... have unknown delay.
   */
  size_t n_stop_time_update;
  TransitRealtime__TripUpdate__StopTimeUpdate **stop_time_update;
  /*
   * The most recent moment at which the vehicle's real-time progress was measured
   * to estimate StopTimes in the future. When StopTimes in the past are provided,
   * arrival/departure times may be earlier than this value. In POSIX
   * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
  /*
   * The current schedule deviation for the trip.  Delay should only be
   * specified when the prediction is given relative to some existing schedule
   * in GTFS.
   * Delay (in seconds) can be positive (meaning that the vehicle is late) or
   * negative (meaning that the vehicle is ahead of schedule). Delay of 0
   * means that the vehicle is exactly on time.
   * Delay information in StopTimeUpdates take precedent of trip-level delay
   * information, such that trip-level delay is only propagated until the next
   * stop along the trip with a StopTimeUpdate delay value specified.
   * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
   * value indicating when the delay value was last updated, in order to
   * evaluate the freshness of the data.
   * NOTE: This field is still experimental, and subject to change. It may be
   * formally adopted in the future.
   */
  protobuf_c_boolean has_delay;
  int32_t delay;
  TransitRealtime__TripUpdate__TripProperties *trip_properties;
};
#define TRANSIT_REALTIME__TRIP_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_update__descriptor) \
, NULL, NULL, 0,NULL, 0, 0, 0, 0, NULL }


/*
 * Carriage specific details, used for vehicles composed of several carriages
 * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__VehiclePosition__CarriageDetails
{
  ProtobufCMessage base;
  /*
   * Identification of the carriage. Should be unique per vehicle.
   */
  char *id;
  /*
   * User visible label that may be shown to the passenger to help identify
   * the carriage. Example: "7712", "Car ABC-32", etc...
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *label;
  /*
   * Occupancy status for this given carriage, in this vehicle
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_occupancy_status;
  TransitRealtime__VehiclePosition__OccupancyStatus occupancy_status;
  /*
   * Occupancy percentage for this given carriage, in this vehicle.
   * Follows the same rules as "VehiclePosition.occupancy_percentage"
   * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_occupancy_percentage;
  int32_t occupancy_percentage;
  /*
   * Identifies the order of this carriage with respect to the other
   * carriages in the vehicle's list of CarriageDetails.
   * The first carriage in the direction of travel must have a value of 1.
   * The second value corresponds to the second carriage in the direction
   * of travel and must have a value of 2, and so forth.
   * For example, the first carriage in the direction of travel has a value of 1.
   * If the second carriage in the direction of travel has a value of 3,
   * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
   * Carriages without data must be represented with a valid carriage_sequence number and the fields 
   * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_carriage_sequence;
  uint32_t carriage_sequence;
};
#define TRANSIT_REALTIME__VEHICLE_POSITION__CARRIAGE_DETAILS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__vehicle_position__carriage_details__descriptor) \
, NULL, NULL, 0, TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__NO_DATA_AVAILABLE, 0, -1, 0, 0 }


/*
 * Realtime positioning information for a given vehicle.
 */
struct  TransitRealtime__VehiclePosition
{
  ProtobufCMessage base;
  /*
   * The Trip that this vehicle is serving.
   * Can be empty or partial if the vehicle can not be identified with a given
   * trip instance.
   */
  TransitRealtime__TripDescriptor *trip;
  /*
   * Additional information on the vehicle that is serving this trip.
   */
  TransitRealtime__VehicleDescriptor *vehicle;
  /*
   * Current position of this vehicle.
   */
  TransitRealtime__Position *position;
  /*
   * The stop sequence index of the current stop. The meaning of
   * current_stop_sequence (i.e., the stop that it refers to) is determined by
   * current_status.
   * If current_status is missing IN_TRANSIT_TO is assumed.
   */
  protobuf_c_boolean has_current_stop_sequence;
  uint32_t current_stop_sequence;
  /*
   * Identifies the current stop. The value must be the same as in stops.txt in
   * the corresponding GTFS feed.
   */
  char *stop_id;
  /*
   * The exact status of the vehicle with respect to the current stop.
   * Ignored if current_stop_sequence is missing.
   */
  protobuf_c_boolean has_current_status;
  TransitRealtime__VehiclePosition__VehicleStopStatus current_status;
  /*
   * Moment at which the vehicle's position was measured. In POSIX time
   * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_timestamp;
  uint64_t timestamp;
  protobuf_c_boolean has_congestion_level;
  TransitRealtime__VehiclePosition__CongestionLevel congestion_level;
  /*
   * If multi_carriage_status is populated with per-carriage OccupancyStatus,
   * then this field should describe the entire vehicle with all carriages accepting passengers considered.
   */
  protobuf_c_boolean has_occupancy_status;
  TransitRealtime__VehiclePosition__OccupancyStatus occupancy_status;
  /*
   * A percentage value indicating the degree of passenger occupancy in the vehicle.
   * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
   * The value 100 should represent the total maximum occupancy the vehicle was designed for,
   * including both seated and standing capacity, and current operating regulations allow.
   * The value may exceed 100 if there are more passengers than the maximum designed capacity.
   * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
   * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
   * then this field should describe the entire vehicle with all carriages accepting passengers considered.
   * This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  protobuf_c_boolean has_occupancy_percentage;
  uint32_t occupancy_percentage;
  /*
   * Details of the multiple carriages of this given vehicle.
   * The first occurrence represents the first carriage of the vehicle, 
   * given the current direction of travel. 
   * The number of occurrences of the multi_carriage_details 
   * field represents the number of carriages of the vehicle.
   * It also includes non boardable carriages, 
   * like engines, maintenance carriages, etc… as they provide valuable 
   * information to passengers about where to stand on a platform.
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  size_t n_multi_carriage_details;
  TransitRealtime__VehiclePosition__CarriageDetails **multi_carriage_details;
};
#define TRANSIT_REALTIME__VEHICLE_POSITION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__vehicle_position__descriptor) \
, NULL, NULL, NULL, 0, 0, NULL, 0, TRANSIT_REALTIME__VEHICLE_POSITION__VEHICLE_STOP_STATUS__IN_TRANSIT_TO, 0, 0, 0, TRANSIT_REALTIME__VEHICLE_POSITION__CONGESTION_LEVEL__UNKNOWN_CONGESTION_LEVEL, 0, TRANSIT_REALTIME__VEHICLE_POSITION__OCCUPANCY_STATUS__EMPTY, 0, 0, 0,NULL }


/*
 * An alert, indicating some sort of incident in the public transit network.
 */
struct  TransitRealtime__Alert
{
  ProtobufCMessage base;
  /*
   * Time when the alert should be shown to the user. If missing, the
   * alert will be shown as long as it appears in the feed.
   * If multiple ranges are given, the alert will be shown during all of them.
   */
  size_t n_active_period;
  TransitRealtime__TimeRange **active_period;
  /*
   * Entities whose users we should notify of this alert.
   */
  size_t n_informed_entity;
  TransitRealtime__EntitySelector **informed_entity;
  protobuf_c_boolean has_cause;
  TransitRealtime__Alert__Cause cause;
  protobuf_c_boolean has_effect;
  TransitRealtime__Alert__Effect effect;
  /*
   * The URL which provides additional information about the alert.
   */
  TransitRealtime__TranslatedString *url;
  /*
   * Alert header. Contains a short summary of the alert text as plain-text.
   */
  TransitRealtime__TranslatedString *header_text;
  /*
   * Full description for the alert as plain-text. The information in the
   * description should add to the information of the header.
   */
  TransitRealtime__TranslatedString *description_text;
  /*
   * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
   */
  TransitRealtime__TranslatedString *tts_header_text;
  /*
   * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
   */
  TransitRealtime__TranslatedString *tts_description_text;
  protobuf_c_boolean has_severity_level;
  TransitRealtime__Alert__SeverityLevel severity_level;
  /*
   * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
   * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TransitRealtime__TranslatedImage *image;
  /*
   * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
   * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TransitRealtime__TranslatedString *image_alternative_text;
  /*
   * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TransitRealtime__TranslatedString *cause_detail;
  /*
   * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  TransitRealtime__TranslatedString *effect_detail;
};
#define TRANSIT_REALTIME__ALERT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__alert__descriptor) \
, 0,NULL, 0,NULL, 0, TRANSIT_REALTIME__ALERT__CAUSE__UNKNOWN_CAUSE, 0, TRANSIT_REALTIME__ALERT__EFFECT__UNKNOWN_EFFECT, NULL, NULL, NULL, NULL, NULL, 0, TRANSIT_REALTIME__ALERT__SEVERITY_LEVEL__UNKNOWN_SEVERITY, NULL, NULL, NULL, NULL }


/*
 * A time interval. The interval is considered active at time 't' if 't' is
 * greater than or equal to the start time and less than the end time.
 */
struct  TransitRealtime__TimeRange
{
  ProtobufCMessage base;
  /*
   * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
   * 00:00:00 UTC).
   * If missing, the interval starts at minus infinity.
   */
  protobuf_c_boolean has_start;
  uint64_t start;
  /*
   * End time, in POSIX time (i.e., number of seconds since January 1st 1970
   * 00:00:00 UTC).
   * If missing, the interval ends at plus infinity.
   */
  protobuf_c_boolean has_end;
  uint64_t end;
};
#define TRANSIT_REALTIME__TIME_RANGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__time_range__descriptor) \
, 0, 0, 0, 0 }


/*
 * A position.
 */
struct  TransitRealtime__Position
{
  ProtobufCMessage base;
  /*
   * Degrees North, in the WGS-84 coordinate system.
   */
  float latitude;
  /*
   * Degrees East, in the WGS-84 coordinate system.
   */
  float longitude;
  /*
   * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
   * This can be the compass bearing, or the direction towards the next stop
   * or intermediate location.
   * This should not be direction deduced from the sequence of previous
   * positions, which can be computed from previous data.
   */
  protobuf_c_boolean has_bearing;
  float bearing;
  /*
   * Odometer value, in meters.
   */
  protobuf_c_boolean has_odometer;
  double odometer;
  /*
   * Momentary speed measured by the vehicle, in meters per second.
   */
  protobuf_c_boolean has_speed;
  float speed;
};
#define TRANSIT_REALTIME__POSITION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__position__descriptor) \
, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  TransitRealtime__TripDescriptor__ModifiedTripSelector
{
  ProtobufCMessage base;
  /*
   * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
   */
  char *modifications_id;
  /*
   * The trip_id from the GTFS feed that is modified by the modifications_id
   */
  char *affected_trip_id;
  /*
   * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
   */
  char *start_time;
  /*
   * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
   */
  char *start_date;
};
#define TRANSIT_REALTIME__TRIP_DESCRIPTOR__MODIFIED_TRIP_SELECTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_descriptor__modified_trip_selector__descriptor) \
, NULL, NULL, NULL, NULL }


/*
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 */
struct  TransitRealtime__TripDescriptor
{
  ProtobufCMessage base;
  /*
   * The trip_id from the GTFS feed that this selector refers to.
   * For non frequency-based trips, this field is enough to uniquely identify
   * the trip. For frequency-based trip, start_time and start_date might also be
   * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
   * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
   * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
   */
  char *trip_id;
  /*
   * The route_id from the GTFS that this selector refers to.
   */
  char *route_id;
  /*
   * The direction_id from the GTFS feed trips.txt file, indicating the
   * direction of travel for trips this selector refers to.
   */
  protobuf_c_boolean has_direction_id;
  uint32_t direction_id;
  /*
   * The initially scheduled start time of this trip instance.
   * When the trip_id corresponds to a non-frequency-based trip, this field
   * should either be omitted or be equal to the value in the GTFS feed. When
   * the trip_id correponds to a frequency-based trip, the start_time must be
   * specified for trip updates and vehicle positions. If the trip corresponds
   * to exact_times=1 GTFS record, then start_time must be some multiple
   * (including zero) of headway_secs later than frequencies.txt start_time for
   * the corresponding time period. If the trip corresponds to exact_times=0,
   * then its start_time may be arbitrary, and is initially expected to be the
   * first departure of the trip. Once established, the start_time of this
   * frequency-based trip should be considered immutable, even if the first
   * departure time changes -- that time change may instead be reflected in a
   * StopTimeUpdate.
   * Format and semantics of the field is same as that of
   * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
   */
  char *start_time;
  /*
   * The scheduled start date of this trip instance.
   * Must be provided to disambiguate trips that are so late as to collide with
   * a scheduled trip on a next day. For example, for a train that departs 8:00
   * and 20:00 every day, and is 12 hours late, there would be two distinct
   * trips on the same time.
   * This field can be provided but is not mandatory for schedules in which such
   * collisions are impossible - for example, a service running on hourly
   * schedule where a vehicle that is one hour late is not considered to be
   * related to schedule anymore.
   * In YYYYMMDD format.
   */
  char *start_date;
  protobuf_c_boolean has_schedule_relationship;
  TransitRealtime__TripDescriptor__ScheduleRelationship schedule_relationship;
  /*
   * Linkage to any modifications done to this trip (shape changes, removal or addition of stops).
   * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value.
   */
  TransitRealtime__TripDescriptor__ModifiedTripSelector *modified_trip;
};
#define TRANSIT_REALTIME__TRIP_DESCRIPTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_descriptor__descriptor) \
, NULL, NULL, 0, 0, NULL, NULL, 0, TRANSIT_REALTIME__TRIP_DESCRIPTOR__SCHEDULE_RELATIONSHIP__SCHEDULED, NULL }


/*
 * Identification information for the vehicle performing the trip.
 */
struct  TransitRealtime__VehicleDescriptor
{
  ProtobufCMessage base;
  /*
   * Internal system identification of the vehicle. Should be unique per
   * vehicle, and can be used for tracking the vehicle as it proceeds through
   * the system.
   */
  char *id;
  /*
   * User visible label, i.e., something that must be shown to the passenger to
   * help identify the correct vehicle.
   */
  char *label;
  /*
   * The license plate of the vehicle.
   */
  char *license_plate;
  protobuf_c_boolean has_wheelchair_accessible;
  TransitRealtime__VehicleDescriptor__WheelchairAccessible wheelchair_accessible;
};
#define TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__vehicle_descriptor__descriptor) \
, NULL, NULL, NULL, 0, TRANSIT_REALTIME__VEHICLE_DESCRIPTOR__WHEELCHAIR_ACCESSIBLE__NO_VALUE }


/*
 * A selector for an entity in a GTFS feed.
 */
struct  TransitRealtime__EntitySelector
{
  ProtobufCMessage base;
  /*
   * The values of the fields should correspond to the appropriate fields in the
   * GTFS feed.
   * At least one specifier must be given. If several are given, then the
   * matching has to apply to all the given specifiers.
   */
  char *agency_id;
  char *route_id;
  /*
   * corresponds to route_type in GTFS.
   */
  protobuf_c_boolean has_route_type;
  int32_t route_type;
  TransitRealtime__TripDescriptor *trip;
  char *stop_id;
  /*
   * Corresponds to trip direction_id in GTFS trips.txt. If provided the
   * route_id must also be provided.
   */
  protobuf_c_boolean has_direction_id;
  uint32_t direction_id;
};
#define TRANSIT_REALTIME__ENTITY_SELECTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__entity_selector__descriptor) \
, NULL, NULL, 0, 0, NULL, NULL, 0, 0 }


struct  TransitRealtime__TranslatedString__Translation
{
  ProtobufCMessage base;
  /*
   * A UTF-8 string containing the message.
   */
  char *text;
  /*
   * BCP-47 language code. Can be omitted if the language is unknown or if
   * no i18n is done at all for the feed. At most one translation is
   * allowed to have an unspecified language tag.
   */
  char *language;
};
#define TRANSIT_REALTIME__TRANSLATED_STRING__TRANSLATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__translated_string__translation__descriptor) \
, NULL, NULL }


/*
 * An internationalized message containing per-language versions of a snippet of
 * text or a URL.
 * One of the strings from a message will be picked up. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 */
struct  TransitRealtime__TranslatedString
{
  ProtobufCMessage base;
  /*
   * At least one translation must be provided.
   */
  size_t n_translation;
  TransitRealtime__TranslatedString__Translation **translation;
};
#define TRANSIT_REALTIME__TRANSLATED_STRING__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__translated_string__descriptor) \
, 0,NULL }


struct  TransitRealtime__TranslatedImage__LocalizedImage
{
  ProtobufCMessage base;
  /*
   * String containing an URL linking to an image
   * The image linked must be less than 2MB. 
   * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
   * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
   */
  char *url;
  /*
   * IANA media type as to specify the type of image to be displayed. 
   * The type must start with "image/"
   */
  char *media_type;
  /*
   * BCP-47 language code. Can be omitted if the language is unknown or if
   * no i18n is done at all for the feed. At most one translation is
   * allowed to have an unspecified language tag.
   */
  char *language;
};
#define TRANSIT_REALTIME__TRANSLATED_IMAGE__LOCALIZED_IMAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__translated_image__localized_image__descriptor) \
, NULL, NULL, NULL }


/*
 * An internationalized image containing per-language versions of a URL linking to an image
 * along with meta information
 * Only one of the images from a message will be retained by consumers. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__TranslatedImage
{
  ProtobufCMessage base;
  /*
   * At least one localized image must be provided.
   */
  size_t n_localized_image;
  TransitRealtime__TranslatedImage__LocalizedImage **localized_image;
};
#define TRANSIT_REALTIME__TRANSLATED_IMAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__translated_image__descriptor) \
, 0,NULL }


/*
 * Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
 * such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
 * Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
 * the location of Stops exactly, but all Stops on a trip should lie within a small distance of
 * the shape for that trip, i.e. close to straight line segments connecting the shape points
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__Shape
{
  ProtobufCMessage base;
  /*
   * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
   * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
   * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *shape_id;
  /*
   * Encoded polyline representation of the shape. This polyline must contain at least two points and represent the full shape of the trip where it's used. 
   * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
   * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
   * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   */
  char *encoded_polyline;
};
#define TRANSIT_REALTIME__SHAPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__shape__descriptor) \
, NULL, NULL }


/*
 * Describes a stop which is served by trips. All fields are as described in the GTFS-Static specification.
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__Stop
{
  ProtobufCMessage base;
  char *stop_id;
  TransitRealtime__TranslatedString *stop_code;
  TransitRealtime__TranslatedString *stop_name;
  TransitRealtime__TranslatedString *tts_stop_name;
  TransitRealtime__TranslatedString *stop_desc;
  protobuf_c_boolean has_stop_lat;
  float stop_lat;
  protobuf_c_boolean has_stop_lon;
  float stop_lon;
  char *zone_id;
  TransitRealtime__TranslatedString *stop_url;
  char *parent_station;
  char *stop_timezone;
  protobuf_c_boolean has_wheelchair_boarding;
  TransitRealtime__Stop__WheelchairBoarding wheelchair_boarding;
  char *level_id;
  TransitRealtime__TranslatedString *platform_code;
};
#define TRANSIT_REALTIME__STOP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__stop__descriptor) \
, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, TRANSIT_REALTIME__STOP__WHEELCHAIR_BOARDING__UNKNOWN, NULL, NULL }


/*
 * A `Modification` message replaces a span of n stop times from each affected trip starting at `start_stop_selector`.
 */
struct  TransitRealtime__TripModifications__Modification
{
  ProtobufCMessage base;
  /*
   * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
   * Used in conjuction with `end_stop_selector`. 
   * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
   */
  TransitRealtime__StopSelector *start_stop_selector;
  /*
   * The stop selector of the last stop of the original trip that is to be affected by this modification. 
   * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
   * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
   */
  TransitRealtime__StopSelector *end_stop_selector;
  /*
   * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
   * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
   */
  protobuf_c_boolean has_propagated_modification_delay;
  int32_t propagated_modification_delay;
  /*
   * A list of replacement stops, replacing those of the original trip. 
   * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
   */
  size_t n_replacement_stops;
  TransitRealtime__ReplacementStop **replacement_stops;
  /*
   * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
   */
  char *service_alert_id;
  /*
   * This timestamp identifies the moment when the modification has last been changed.
   * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   */
  protobuf_c_boolean has_last_modified_time;
  uint64_t last_modified_time;
};
#define TRANSIT_REALTIME__TRIP_MODIFICATIONS__MODIFICATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_modifications__modification__descriptor) \
, NULL, NULL, 0, 0, 0,NULL, NULL, 0, 0 }


struct  TransitRealtime__TripModifications__SelectedTrips
{
  ProtobufCMessage base;
  /*
   * A list of trips affected with this replacement that all have the same new `shape_id`. A `TripUpdate` with `schedule_relationship=REPLACEMENT` must not already exist for the trip.
   */
  size_t n_trip_ids;
  char **trip_ids;
  /*
   * The ID of the new shape for the modified trips in this SelectedTrips. 
   * May refer to a new shape added using a `Shape` message in the same GTFS-RT feed, or to an existing shape defined in the GTFS-Static feed’s shapes.txt. 
   * If it refers to a `Shape` entity in the real-time feed, the value of this field should be the one of the `shape_id` inside the entity, and _not_ the `id` of `FeedEntity`.
   */
  char *shape_id;
};
#define TRANSIT_REALTIME__TRIP_MODIFICATIONS__SELECTED_TRIPS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_modifications__selected_trips__descriptor) \
, 0,NULL, NULL }


/*
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__TripModifications
{
  ProtobufCMessage base;
  /*
   * A list of selected trips affected by this TripModifications.
   */
  size_t n_selected_trips;
  TransitRealtime__TripModifications__SelectedTrips **selected_trips;
  /*
   * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
   * Useful to target multiple departures of a trip_id in a frequency-based trip.
   */
  size_t n_start_times;
  char **start_times;
  /*
   * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
   * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
   */
  size_t n_service_dates;
  char **service_dates;
  /*
   * A list of modifications to apply to the affected trips. 
   */
  size_t n_modifications;
  TransitRealtime__TripModifications__Modification **modifications;
};
#define TRANSIT_REALTIME__TRIP_MODIFICATIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__trip_modifications__descriptor) \
, 0,NULL, 0,NULL, 0,NULL, 0,NULL }


/*
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 * Select a stop by stop sequence or by stop_id. At least one of the two values must be provided.
 */
struct  TransitRealtime__StopSelector
{
  ProtobufCMessage base;
  /*
   * Must be the same as in stop_times.txt in the corresponding GTFS feed.
   */
  protobuf_c_boolean has_stop_sequence;
  uint32_t stop_sequence;
  /*
   * Must be the same as in stops.txt in the corresponding GTFS feed.
   */
  char *stop_id;
};
#define TRANSIT_REALTIME__STOP_SELECTOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__stop_selector__descriptor) \
, 0, 0, NULL }


/*
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 */
struct  TransitRealtime__ReplacementStop
{
  ProtobufCMessage base;
  /*
   * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
   * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
   */
  protobuf_c_boolean has_travel_time_to_stop;
  int32_t travel_time_to_stop;
  /*
   * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT `Stop` message in the same GTFS-RT feed, or to an existing stop defined in the (CSV) GTFS feed’s `stops.txt`.
   * If it refers to a `Shape` entity in the real-time feed, the value of this field should be the one of the `stop_id` inside the entity, and _not_ the `id` of `FeedEntity`. The replacement stop MUST have `location_type=0` (routable stops).
   */
  char *stop_id;
};
#define TRANSIT_REALTIME__REPLACEMENT_STOP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&transit_realtime__replacement_stop__descriptor) \
, 0, 0, NULL }


/* TransitRealtime__FeedMessage methods */
void   transit_realtime__feed_message__init
                     (TransitRealtime__FeedMessage         *message);
size_t transit_realtime__feed_message__get_packed_size
                     (const TransitRealtime__FeedMessage   *message);
size_t transit_realtime__feed_message__pack
                     (const TransitRealtime__FeedMessage   *message,
                      uint8_t             *out);
size_t transit_realtime__feed_message__pack_to_buffer
                     (const TransitRealtime__FeedMessage   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__FeedMessage *
       transit_realtime__feed_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__feed_message__free_unpacked
                     (TransitRealtime__FeedMessage *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__FeedHeader methods */
void   transit_realtime__feed_header__init
                     (TransitRealtime__FeedHeader         *message);
size_t transit_realtime__feed_header__get_packed_size
                     (const TransitRealtime__FeedHeader   *message);
size_t transit_realtime__feed_header__pack
                     (const TransitRealtime__FeedHeader   *message,
                      uint8_t             *out);
size_t transit_realtime__feed_header__pack_to_buffer
                     (const TransitRealtime__FeedHeader   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__FeedHeader *
       transit_realtime__feed_header__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__feed_header__free_unpacked
                     (TransitRealtime__FeedHeader *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__FeedEntity methods */
void   transit_realtime__feed_entity__init
                     (TransitRealtime__FeedEntity         *message);
size_t transit_realtime__feed_entity__get_packed_size
                     (const TransitRealtime__FeedEntity   *message);
size_t transit_realtime__feed_entity__pack
                     (const TransitRealtime__FeedEntity   *message,
                      uint8_t             *out);
size_t transit_realtime__feed_entity__pack_to_buffer
                     (const TransitRealtime__FeedEntity   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__FeedEntity *
       transit_realtime__feed_entity__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__feed_entity__free_unpacked
                     (TransitRealtime__FeedEntity *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TripUpdate__StopTimeEvent methods */
void   transit_realtime__trip_update__stop_time_event__init
                     (TransitRealtime__TripUpdate__StopTimeEvent         *message);
/* TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties methods */
void   transit_realtime__trip_update__stop_time_update__stop_time_properties__init
                     (TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties         *message);
/* TransitRealtime__TripUpdate__StopTimeUpdate methods */
void   transit_realtime__trip_update__stop_time_update__init
                     (TransitRealtime__TripUpdate__StopTimeUpdate         *message);
/* TransitRealtime__TripUpdate__TripProperties methods */
void   transit_realtime__trip_update__trip_properties__init
                     (TransitRealtime__TripUpdate__TripProperties         *message);
/* TransitRealtime__TripUpdate methods */
void   transit_realtime__trip_update__init
                     (TransitRealtime__TripUpdate         *message);
size_t transit_realtime__trip_update__get_packed_size
                     (const TransitRealtime__TripUpdate   *message);
size_t transit_realtime__trip_update__pack
                     (const TransitRealtime__TripUpdate   *message,
                      uint8_t             *out);
size_t transit_realtime__trip_update__pack_to_buffer
                     (const TransitRealtime__TripUpdate   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TripUpdate *
       transit_realtime__trip_update__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__trip_update__free_unpacked
                     (TransitRealtime__TripUpdate *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__VehiclePosition__CarriageDetails methods */
void   transit_realtime__vehicle_position__carriage_details__init
                     (TransitRealtime__VehiclePosition__CarriageDetails         *message);
/* TransitRealtime__VehiclePosition methods */
void   transit_realtime__vehicle_position__init
                     (TransitRealtime__VehiclePosition         *message);
size_t transit_realtime__vehicle_position__get_packed_size
                     (const TransitRealtime__VehiclePosition   *message);
size_t transit_realtime__vehicle_position__pack
                     (const TransitRealtime__VehiclePosition   *message,
                      uint8_t             *out);
size_t transit_realtime__vehicle_position__pack_to_buffer
                     (const TransitRealtime__VehiclePosition   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__VehiclePosition *
       transit_realtime__vehicle_position__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__vehicle_position__free_unpacked
                     (TransitRealtime__VehiclePosition *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__Alert methods */
void   transit_realtime__alert__init
                     (TransitRealtime__Alert         *message);
size_t transit_realtime__alert__get_packed_size
                     (const TransitRealtime__Alert   *message);
size_t transit_realtime__alert__pack
                     (const TransitRealtime__Alert   *message,
                      uint8_t             *out);
size_t transit_realtime__alert__pack_to_buffer
                     (const TransitRealtime__Alert   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__Alert *
       transit_realtime__alert__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__alert__free_unpacked
                     (TransitRealtime__Alert *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TimeRange methods */
void   transit_realtime__time_range__init
                     (TransitRealtime__TimeRange         *message);
size_t transit_realtime__time_range__get_packed_size
                     (const TransitRealtime__TimeRange   *message);
size_t transit_realtime__time_range__pack
                     (const TransitRealtime__TimeRange   *message,
                      uint8_t             *out);
size_t transit_realtime__time_range__pack_to_buffer
                     (const TransitRealtime__TimeRange   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TimeRange *
       transit_realtime__time_range__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__time_range__free_unpacked
                     (TransitRealtime__TimeRange *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__Position methods */
void   transit_realtime__position__init
                     (TransitRealtime__Position         *message);
size_t transit_realtime__position__get_packed_size
                     (const TransitRealtime__Position   *message);
size_t transit_realtime__position__pack
                     (const TransitRealtime__Position   *message,
                      uint8_t             *out);
size_t transit_realtime__position__pack_to_buffer
                     (const TransitRealtime__Position   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__Position *
       transit_realtime__position__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__position__free_unpacked
                     (TransitRealtime__Position *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TripDescriptor__ModifiedTripSelector methods */
void   transit_realtime__trip_descriptor__modified_trip_selector__init
                     (TransitRealtime__TripDescriptor__ModifiedTripSelector         *message);
/* TransitRealtime__TripDescriptor methods */
void   transit_realtime__trip_descriptor__init
                     (TransitRealtime__TripDescriptor         *message);
size_t transit_realtime__trip_descriptor__get_packed_size
                     (const TransitRealtime__TripDescriptor   *message);
size_t transit_realtime__trip_descriptor__pack
                     (const TransitRealtime__TripDescriptor   *message,
                      uint8_t             *out);
size_t transit_realtime__trip_descriptor__pack_to_buffer
                     (const TransitRealtime__TripDescriptor   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TripDescriptor *
       transit_realtime__trip_descriptor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__trip_descriptor__free_unpacked
                     (TransitRealtime__TripDescriptor *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__VehicleDescriptor methods */
void   transit_realtime__vehicle_descriptor__init
                     (TransitRealtime__VehicleDescriptor         *message);
size_t transit_realtime__vehicle_descriptor__get_packed_size
                     (const TransitRealtime__VehicleDescriptor   *message);
size_t transit_realtime__vehicle_descriptor__pack
                     (const TransitRealtime__VehicleDescriptor   *message,
                      uint8_t             *out);
size_t transit_realtime__vehicle_descriptor__pack_to_buffer
                     (const TransitRealtime__VehicleDescriptor   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__VehicleDescriptor *
       transit_realtime__vehicle_descriptor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__vehicle_descriptor__free_unpacked
                     (TransitRealtime__VehicleDescriptor *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__EntitySelector methods */
void   transit_realtime__entity_selector__init
                     (TransitRealtime__EntitySelector         *message);
size_t transit_realtime__entity_selector__get_packed_size
                     (const TransitRealtime__EntitySelector   *message);
size_t transit_realtime__entity_selector__pack
                     (const TransitRealtime__EntitySelector   *message,
                      uint8_t             *out);
size_t transit_realtime__entity_selector__pack_to_buffer
                     (const TransitRealtime__EntitySelector   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__EntitySelector *
       transit_realtime__entity_selector__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__entity_selector__free_unpacked
                     (TransitRealtime__EntitySelector *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TranslatedString__Translation methods */
void   transit_realtime__translated_string__translation__init
                     (TransitRealtime__TranslatedString__Translation         *message);
/* TransitRealtime__TranslatedString methods */
void   transit_realtime__translated_string__init
                     (TransitRealtime__TranslatedString         *message);
size_t transit_realtime__translated_string__get_packed_size
                     (const TransitRealtime__TranslatedString   *message);
size_t transit_realtime__translated_string__pack
                     (const TransitRealtime__TranslatedString   *message,
                      uint8_t             *out);
size_t transit_realtime__translated_string__pack_to_buffer
                     (const TransitRealtime__TranslatedString   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TranslatedString *
       transit_realtime__translated_string__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__translated_string__free_unpacked
                     (TransitRealtime__TranslatedString *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TranslatedImage__LocalizedImage methods */
void   transit_realtime__translated_image__localized_image__init
                     (TransitRealtime__TranslatedImage__LocalizedImage         *message);
/* TransitRealtime__TranslatedImage methods */
void   transit_realtime__translated_image__init
                     (TransitRealtime__TranslatedImage         *message);
size_t transit_realtime__translated_image__get_packed_size
                     (const TransitRealtime__TranslatedImage   *message);
size_t transit_realtime__translated_image__pack
                     (const TransitRealtime__TranslatedImage   *message,
                      uint8_t             *out);
size_t transit_realtime__translated_image__pack_to_buffer
                     (const TransitRealtime__TranslatedImage   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TranslatedImage *
       transit_realtime__translated_image__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__translated_image__free_unpacked
                     (TransitRealtime__TranslatedImage *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__Shape methods */
void   transit_realtime__shape__init
                     (TransitRealtime__Shape         *message);
size_t transit_realtime__shape__get_packed_size
                     (const TransitRealtime__Shape   *message);
size_t transit_realtime__shape__pack
                     (const TransitRealtime__Shape   *message,
                      uint8_t             *out);
size_t transit_realtime__shape__pack_to_buffer
                     (const TransitRealtime__Shape   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__Shape *
       transit_realtime__shape__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__shape__free_unpacked
                     (TransitRealtime__Shape *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__Stop methods */
void   transit_realtime__stop__init
                     (TransitRealtime__Stop         *message);
size_t transit_realtime__stop__get_packed_size
                     (const TransitRealtime__Stop   *message);
size_t transit_realtime__stop__pack
                     (const TransitRealtime__Stop   *message,
                      uint8_t             *out);
size_t transit_realtime__stop__pack_to_buffer
                     (const TransitRealtime__Stop   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__Stop *
       transit_realtime__stop__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__stop__free_unpacked
                     (TransitRealtime__Stop *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__TripModifications__Modification methods */
void   transit_realtime__trip_modifications__modification__init
                     (TransitRealtime__TripModifications__Modification         *message);
/* TransitRealtime__TripModifications__SelectedTrips methods */
void   transit_realtime__trip_modifications__selected_trips__init
                     (TransitRealtime__TripModifications__SelectedTrips         *message);
/* TransitRealtime__TripModifications methods */
void   transit_realtime__trip_modifications__init
                     (TransitRealtime__TripModifications         *message);
size_t transit_realtime__trip_modifications__get_packed_size
                     (const TransitRealtime__TripModifications   *message);
size_t transit_realtime__trip_modifications__pack
                     (const TransitRealtime__TripModifications   *message,
                      uint8_t             *out);
size_t transit_realtime__trip_modifications__pack_to_buffer
                     (const TransitRealtime__TripModifications   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__TripModifications *
       transit_realtime__trip_modifications__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__trip_modifications__free_unpacked
                     (TransitRealtime__TripModifications *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__StopSelector methods */
void   transit_realtime__stop_selector__init
                     (TransitRealtime__StopSelector         *message);
size_t transit_realtime__stop_selector__get_packed_size
                     (const TransitRealtime__StopSelector   *message);
size_t transit_realtime__stop_selector__pack
                     (const TransitRealtime__StopSelector   *message,
                      uint8_t             *out);
size_t transit_realtime__stop_selector__pack_to_buffer
                     (const TransitRealtime__StopSelector   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__StopSelector *
       transit_realtime__stop_selector__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__stop_selector__free_unpacked
                     (TransitRealtime__StopSelector *message,
                      ProtobufCAllocator *allocator);
/* TransitRealtime__ReplacementStop methods */
void   transit_realtime__replacement_stop__init
                     (TransitRealtime__ReplacementStop         *message);
size_t transit_realtime__replacement_stop__get_packed_size
                     (const TransitRealtime__ReplacementStop   *message);
size_t transit_realtime__replacement_stop__pack
                     (const TransitRealtime__ReplacementStop   *message,
                      uint8_t             *out);
size_t transit_realtime__replacement_stop__pack_to_buffer
                     (const TransitRealtime__ReplacementStop   *message,
                      ProtobufCBuffer     *buffer);
TransitRealtime__ReplacementStop *
       transit_realtime__replacement_stop__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   transit_realtime__replacement_stop__free_unpacked
                     (TransitRealtime__ReplacementStop *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*TransitRealtime__FeedMessage_Closure)
                 (const TransitRealtime__FeedMessage *message,
                  void *closure_data);
typedef void (*TransitRealtime__FeedHeader_Closure)
                 (const TransitRealtime__FeedHeader *message,
                  void *closure_data);
typedef void (*TransitRealtime__FeedEntity_Closure)
                 (const TransitRealtime__FeedEntity *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate__StopTimeEvent_Closure)
                 (const TransitRealtime__TripUpdate__StopTimeEvent *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties_Closure)
                 (const TransitRealtime__TripUpdate__StopTimeUpdate__StopTimeProperties *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate__StopTimeUpdate_Closure)
                 (const TransitRealtime__TripUpdate__StopTimeUpdate *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate__TripProperties_Closure)
                 (const TransitRealtime__TripUpdate__TripProperties *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripUpdate_Closure)
                 (const TransitRealtime__TripUpdate *message,
                  void *closure_data);
typedef void (*TransitRealtime__VehiclePosition__CarriageDetails_Closure)
                 (const TransitRealtime__VehiclePosition__CarriageDetails *message,
                  void *closure_data);
typedef void (*TransitRealtime__VehiclePosition_Closure)
                 (const TransitRealtime__VehiclePosition *message,
                  void *closure_data);
typedef void (*TransitRealtime__Alert_Closure)
                 (const TransitRealtime__Alert *message,
                  void *closure_data);
typedef void (*TransitRealtime__TimeRange_Closure)
                 (const TransitRealtime__TimeRange *message,
                  void *closure_data);
typedef void (*TransitRealtime__Position_Closure)
                 (const TransitRealtime__Position *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripDescriptor__ModifiedTripSelector_Closure)
                 (const TransitRealtime__TripDescriptor__ModifiedTripSelector *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripDescriptor_Closure)
                 (const TransitRealtime__TripDescriptor *message,
                  void *closure_data);
typedef void (*TransitRealtime__VehicleDescriptor_Closure)
                 (const TransitRealtime__VehicleDescriptor *message,
                  void *closure_data);
typedef void (*TransitRealtime__EntitySelector_Closure)
                 (const TransitRealtime__EntitySelector *message,
                  void *closure_data);
typedef void (*TransitRealtime__TranslatedString__Translation_Closure)
                 (const TransitRealtime__TranslatedString__Translation *message,
                  void *closure_data);
typedef void (*TransitRealtime__TranslatedString_Closure)
                 (const TransitRealtime__TranslatedString *message,
                  void *closure_data);
typedef void (*TransitRealtime__TranslatedImage__LocalizedImage_Closure)
                 (const TransitRealtime__TranslatedImage__LocalizedImage *message,
                  void *closure_data);
typedef void (*TransitRealtime__TranslatedImage_Closure)
                 (const TransitRealtime__TranslatedImage *message,
                  void *closure_data);
typedef void (*TransitRealtime__Shape_Closure)
                 (const TransitRealtime__Shape *message,
                  void *closure_data);
typedef void (*TransitRealtime__Stop_Closure)
                 (const TransitRealtime__Stop *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripModifications__Modification_Closure)
                 (const TransitRealtime__TripModifications__Modification *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripModifications__SelectedTrips_Closure)
                 (const TransitRealtime__TripModifications__SelectedTrips *message,
                  void *closure_data);
typedef void (*TransitRealtime__TripModifications_Closure)
                 (const TransitRealtime__TripModifications *message,
                  void *closure_data);
typedef void (*TransitRealtime__StopSelector_Closure)
                 (const TransitRealtime__StopSelector *message,
                  void *closure_data);
typedef void (*TransitRealtime__ReplacementStop_Closure)
                 (const TransitRealtime__ReplacementStop *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor transit_realtime__feed_message__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__feed_header__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__feed_header__incrementality__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__feed_entity__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__stop_time_event__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__stop_time_update__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__stop_time_update__stop_time_properties__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__trip_update__stop_time_update__stop_time_properties__drop_off_pickup_type__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__trip_update__stop_time_update__schedule_relationship__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_update__trip_properties__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__vehicle_position__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__vehicle_position__carriage_details__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__vehicle_position__vehicle_stop_status__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__vehicle_position__congestion_level__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__vehicle_position__occupancy_status__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__alert__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__alert__cause__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__alert__effect__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__alert__severity_level__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__time_range__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__position__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_descriptor__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_descriptor__modified_trip_selector__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__trip_descriptor__schedule_relationship__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__vehicle_descriptor__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__vehicle_descriptor__wheelchair_accessible__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__entity_selector__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__translated_string__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__translated_string__translation__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__translated_image__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__translated_image__localized_image__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__shape__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__stop__descriptor;
extern const ProtobufCEnumDescriptor    transit_realtime__stop__wheelchair_boarding__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_modifications__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_modifications__modification__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__trip_modifications__selected_trips__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__stop_selector__descriptor;
extern const ProtobufCMessageDescriptor transit_realtime__replacement_stop__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_proto_2fgtfs_2drealtime_2eproto__INCLUDED */
